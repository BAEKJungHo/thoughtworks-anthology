# 객체지향 생활체조

- 훈련 규칙
  - 한 메서드에 오직 한 단계의 들여쓰기만 한다.
  - else 예약어를 쓰지 않는다.
  - 모든 원시값과 문자열을 포장(wrap)한다.
  - 한 줄에 점을 하나만 찍는다.
  - 줄여쓰지 않는다.
  - 모든 엔티티(entity)를 작게 유지한다.
  - 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
  - first-class 컬렉션을 사용한다.
  - getter/setter property 를 쓰지 않는다.
  
 ## 규칙 1. 메서드당 들여쓰기 한 번
  
 > 메서드당 하나의 제어구조나 하나의 문장 단락(block)으로 되어 있는지 지키려고 노력해야한다.
  
```java
class Board {
    ...
    String board() {
      StringBuffer buf = new StringBuffer();
      for(int i=0; i<10; i++) {
        for(int k=0; k<10; k++) {
          buf.append(data[i][j]);
          }
        buf.append("\n");
      }
      return buf.toString();
   }    
}
```

- After Refactoring

```java
String board() {
  StringBuffer bf = new StringBuffer();
  collectRows(buf);
  return buf.toString();
}

void collectRows(StringBuffer buf) {
  for(int i=0; i<10; i++) {
    collectRow(buf, i);
  }
}

void collectRow(StringBuffer buf, int row) {
  for(int i=0; i<10; i++) {
    buf.append(data[row][i]);
  }
  buf.append("\n");
}
```

이렇게 작게 잘 분할된 코드는 버그도 찾기 쉬우며, 가독성도 뛰어나서 유지보수에 좋다. 또한 재사용성이 많이 증가한다.

## 규칙 2. else 예약어 금지

조건문은 복제의 원흉이기도 하다. 예를들어 아래의 status 플래그는 자주 이런 문제에 빠진다.

```java
public static void endMe() {
  if(status == DONE) {
    doSomething();
  } else {
    // other code
  }
}
```

- else 제거

```java
public static void endMe() {
  if(status == DONE) {
    doSomething();
    return;
  } 
  // other code
}
```

```java
public static Node head() {
  if(isAdvancing()) { return first; }
  else { return last; }
}
```

```java
public static Node head() {
  return isAdvancing() ? fisrt : last;
}
```

5줄이 1줄로 줄어들었따. return 문을 일찍 쓰는 것을 너무 많이 하면 간결함을 저해하기 쉽다는 점을 간과해서는 안된다.

Strategy 패턴에서는 상태 인라인(status inline)에 분기를 막기 위해 다형성을 쓰는 예제가 있다. 상태에 대한 분기가 몇 군데 걸쳐 중복되어 있을 때 Strategy 패턴은 유용하다.

객체지향 언어는 다형성이라는 강력한 도구를 통해 복잡한 조건문을 처리할 수 있다. 간단한 경우라면 `보호절(guard clause) 과 조기 반환(early return)` 으로 대체 가능하다.
