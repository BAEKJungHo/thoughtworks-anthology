# 객체지향 생활체조

- 훈련 규칙
  - 한 메서드에 오직 한 단계의 들여쓰기만 한다.
  - else 예약어를 쓰지 않는다.
  - 모든 원시값과 문자열을 포장(wrap)한다.
  - 한 줄에 점을 하나만 찍는다.
  - 줄여쓰지 않는다.
  - 모든 엔티티(entity)를 작게 유지한다.
  - 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
  - first-class 컬렉션을 사용한다.
  - getter/setter property 를 쓰지 않는다.
  
 ## 규칙 1. 메서드당 들여쓰기 한 번
  
 > 메서드당 하나의 제어구조나 하나의 문장 단락(block)으로 되어 있는지 지키려고 노력해야한다.
  
```java
class Board {
    ...
    String board() {
      StringBuffer buf = new StringBuffer();
      for(int i=0; i<10; i++) {
        for(int k=0; k<10; k++) {
          buf.append(data[i][j]);
          }
        buf.append("\n");
      }
      return buf.toString();
   }    
}
```

- After Refactoring

```java
String board() {
  StringBuffer bf = new StringBuffer();
  collectRows(buf);
  return buf.toString();
}

void collectRows(StringBuffer buf) {
  for(int i=0; i<10; i++) {
    collectRow(buf, i);
  }
}

void collectRow(StringBuffer buf, int row) {
  for(int i=0; i<10; i++) {
    buf.append(data[row][i]);
  }
  buf.append("\n");
}
```

이렇게 작게 잘 분할된 코드는 버그도 찾기 쉬우며, 가독성도 뛰어나서 유지보수에 좋다. 또한 재사용성이 많이 증가한다.

## 규칙 2. else 예약어 금지

조건문은 복제의 원흉이기도 하다. 예를들어 아래의 status 플래그는 자주 이런 문제에 빠진다.

```java
public static void endMe() {
  if(status == DONE) {
    doSomething();
  } else {
    // other code
  }
}
```

- else 제거

```java
public static void endMe() {
  if(status == DONE) {
    doSomething();
    return;
  } 
  // other code
}
```

```java
public static Node head() {
  if(isAdvancing()) { return first; }
  else { return last; }
}
```

```java
public static Node head() {
  return isAdvancing() ? fisrt : last;
}
```

5줄이 1줄로 줄어들었다. return 문을 일찍 쓰는 것을 너무 많이 하면 간결함을 저해하기 쉽다는 점을 간과해서는 안된다.

Strategy 패턴에서는 상태 인라인(status inline)에 분기를 막기 위해 다형성을 쓰는 예제가 있다. 상태에 대한 분기가 몇 군데 걸쳐 중복되어 있을 때 Strategy 패턴은 유용하다.

객체지향 언어는 다형성이라는 강력한 도구를 통해 복잡한 조건문을 처리할 수 있다. 간단한 경우라면 `보호절(guard clause) 과 조기 반환(early return)` 으로 대체 가능하다.

## 규칙 3. 원시값과 문자열의 포장

int 값 하나 자체는 아무 의미 없는 스칼라 값일 뿐이다. 어떤 메서드가 int 값을 매개변수로 받는다면 그 메서드 이름은 해당 매개변수의 의도를 나타내기위해 수단과 방법을 가리면 안된다.

시간을 매개변수로 받을 경우, 메서드에게 연도 값을 넘길 수는 없다.

원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다. 오브젝트라면 아주 사소하더라도 컴파일러와 프로그래머에게 어떤 값이며 왜 쓰이고 있는지에 대한 정보를 전하는 셈이다.

시간이나 돈과 같은 작은 오브젝트는 또한 분명한 위치를 행위에 부여하여, 그렇지 않으면 다른 클래스의 주위를 겉돌았을지도 모르는 사태를 방지한다.

- __원시 값을 포장함으로써 의미를 갖게 된다.__
- __포장된 원시 값에 대한 검증 로직들을 하나의 클래스에 모을 수 있어서 응집력이 높아진다.__

```java
public class Fare {
 
    public static final int BASE_FARE = 1250;
    private int fare;

    private Fare(int fare) {
        this.fare = fare;
    }

    public static Fare from(int fare) {
        return new Fare(fare);
    }

    public void add(int fare) {
        this.fare += fare;
    }

    public int getValue() {
        return this.fare;
    }
}
```

## 규칙 4. 한 줄에 한 점만 사용

여러 개의 점이 들어 있는 코드 몇 줄을 들여다보기 시작하면, 책임소재의 오류를 많이 발견하기 시작한다. 어떠한 코드 한 줄에서라도 점이 하나 이상 있으면 동작이 일어나고 있다는 뜻이다.
이 경우 그 오브젝트는 중개상, 즉 너무 많은 사람들에게 대해 지나치게 알고 있는 꼴이다.

중복된 점들은 캡슐화를 어기고 있다는 방증이다. 오브젝트가 자기 속을 들여다 보려 하기보다는 뭔가 작업을 하도록 만들려고 해야 한다.

> 디미터 법칙(Law of Demeter, 친구하고만 대화하라)는 이 규칙의 좋은 출발 점이다.

## 규칙 5. 축약 금지

축약은 혼란을 야기하며, 더 큰 문제를 숨기는 경향이 있다.

클래스 이름이 Order 라면 메서드 이름을 shipOrder 라고 지을 필요가 없다. ship 이라고 지으면 order.ship() 이라고 간결하게 호출할 수 있다.

이 훈련을 위해 모든 엔티티는 한두 단어로 된 이름을 축약 없이 가져야한다.

## 규칙 6. 모든 엔티티를 작게 유지

이 말은 50 줄 이상 되는 클래스와 10 개 파일 이상 되는 패키지는 없어야 한다는 뜻이다.

50 줄 이상 되는 클래스는 보통 한 가지 이상의 일을 하는 것이며, 따라서 코드의 이해와 재사용을 점점 더 어렵게 끌고간다.

50 줄짜리 클래스는 스크롤 없이 한 화면에 볼 수 있고, 파악하기도 쉽다.

클래스가 점점 작아지며 하는 일이 줄어들며 패키지 크기를 제한함에 따라 패키지가 하나의 목적을 달성하기 위해 모인 연고나 클래스들의 집합을 나타냄을 알아채기 시작한다.
패키지도 클래스처럼 응집력있고 단일한 목표가 있어야 한다.

## 규칙 7. 2개 이상의 인스턴스 변수를 가진 클래스 사용 금지

많은 인스턴스 변수를 지닌 클래스를 대상으로 응집력 있는 단일 작업을 설명할 수 있는 경우는 거의 없다.

## 규칙 8. 일급 컬렉션 사용

이 규칙은 간단하다. 컬렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다. 각 컬렉션은 그 자체로 포장이 되어 있으므로 이제 컬렉션과 관련된 동작은 근거지가 마련된 셈이다.
필터가 이 새 클래스의 일부가 됨을 알 수 있다. 필터는 또한 스스로 함수 오브젝트가 될 수 있다. 또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을
처리할 수 있다.

## 규칙 9. 게터/세터/속성 사용 금지

이 규칙은 흔히 `말을 해, 묻지 말고` 라고 일컫는다.

# 왜 객체지향 생활 체조 원칙인가?

객체지향 설계와 구현은 수학 공식을 외워서 문제를 푸는 것과 달리 이론을 안다고 해도 이 이론을 설계와 구현에 녹여내려면 지속적인 수련이 필요한 영역이다.
여기서 수련이라는 의미는 어느 누구나 야구공을 던지는 이론은 다 알고 있지만 이론을 안다고 누구나 다 프로선수 처럼 공을 던질 순 없고 지속적인 훈련(수련)을 통해서만 가능하다.

많은 개발자들이 지속적인 수련이 중요하다는 것은 알기 때문에 객체지향 설계와 구현 연습에 도전한다.
하지만 객체지향 설계를 다루고 있는 대부분의 책이 추상적인 이론을 다루고 있기 때문에 초보 개발자는 몇 번 도전 후에 포기하는 상황이 발생한다.
특히 어려운 점은 소스 코드 중 문제가 있는 부분을 찾는 것이다. 어떻게 리팩토링할 것인지는 그 다음 이슈이다.
개선할 부분을 찾지도 못하는 개발자들에게 아무리 객체지향 설계와 구현과 관련한 이론을 제시해도 무용지물이다.

객체지향 생활 체조 원칙은 추상적인 가이드가 아니라 구체적인 가이드를 제시하고 있다.
따라서 초보 개발자도 코드 중에서 리팩토링할 부분(Bad Smell이 있는 부분)이 있는 코드를 쉽게 찾을 수 있으며, 도전해 볼 수 있다.
예를 들어 "규칙 1: 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다."는 정말 구체적이다.
코드 중 들여쓰기가 2 이상인 코드가 있다면 그 부분을 어떻게 리팩토링할 것인지 고민하면 된다.

이와 같이 구체적인 가이드를 통해 꾸준히 수련하다보면 어느 순간 객체지향 설계와 관련한 추상적인 이론들이 이해되는 시점이 찾아온다.
